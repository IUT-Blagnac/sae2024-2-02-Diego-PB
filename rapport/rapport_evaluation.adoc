= Rapport d'évaluation des Algotithmes
:author: Diego Penicaud-Bernal / BUT 1 Informatique / Groupe 4A

== Sommaire

[.text]
* <<Liste des Algorithmes>>
* <<Evaluation des Algorithmes>>


== Liste des Algorithmes

=== Simplicite

|===
| Fichier | Langage | Lien vers le code
| 59simplicite.java | Java   | link:../analyse/59simplicite.java[Code]
| 26simplicite.py   | Python | link:../analyse/26simplicite.py[Code]
| 07simplicite.py   | Python | link:../analyse/07simplicite.py[Code]   
| 11simplicite.java | Java   | link:../analyse/11simplicite.java[Code]
| 52simplicite.java | Java   | link:../analyse/52simplicite.java[Code]
|===

=== Efficacite

|===
| Fichier | Langage | Lien
| 27efficacite.py   | Python | link:../analyse/27efficacite.py[Code]
| 25efficacite.java | Java   | link:../analyse/25efficacite.java[Code]
| 24efficacite.java | Java   | link:../analyse/24efficacite.java[Code]
| 10efficacite.java | Java   | link:../analyse/10efficacite.java[Code]
| 61efficacite.java | Java   | link:../analyse/61efficacite.java[Code]
|===

=== Sobriete

|===
| Fichier | Langage | Lien

| 46sobriete.java | Java | link:../analyse/46sobriete.java[Code]
| 36sobriete.java | Java | link:../analyse/36sobriete.java[Code]
| 20sobriete.java | Java | link:../analyse/20sobriete.java[Code]
| 61sobriete.c    | C    | link:../analyse/61sobriete.c[Code]

|===

== Evaluation des Algorithmes

=== 59simplicite.java  

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Le code fonctionne et passe les tests fournis initialement
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

* L'algorithme est bien codé, il respecte les consignes et passe tous les tests.

* Le code est lisible et bien structuré.

* Les noms de variables sont explicites.
** Certain nom de variable sont anglais et d'autre en francais, ce qui me   penser que le developpeur deriere ce code a utilisé une ia.

* Tout est correctement commenté.

J'attribue la note de 20/20
 
=== 26simplicite.py  

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Oui
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

* L'algorithme est bien codé, il respecte les consignes et passe tous les tests.

* Le code est lisible et bien structuré.

* Les noms de variables sont explicites.

* Le code pourait etre plus commenté (description de se que   la fonction, des parametres de la fonctione et de se que cela retourne).

J'attribue la note de 20/20

=== 07simplicite.py  
 
|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Le code fonctionne et passe les tests fournis initialement
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

* L'algorithme est bien codé, il respecte les consignes et passe tous les tests.

* Le code est lisible et bien structuré.

* Les noms de variables sont explicites.

* Le code est bien commenté.

J'attribue la note de 20/20

=== 11simplicite.java  

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Le code fonctionne et passe les tests fournis initialement
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

* L'algorithme est bien codé, il respecte les consignes et passe tous les tests.

* Le code est lisible et bien structuré.

* Les noms de variables sont explicites.
** Certain nom de variable sont anglais et d'autre en francais, ce qui me   penser que le developpeur deriere ce code a utilisé une ia.

* Tout est correctement commenté.

J'attribue la note de 20/20

=== 52simplicite.java  

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Le code fonctionne et passe les tests fournis initialement
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

* L'algorithme est bien codé, il respecte les consignes et passe tous les tests.

* Le code est lisible et bien structuré.

* Les noms de variables sont explicites.
** Certain nom de variable sont anglais et d'autre en francais, ce qui me   penser que le developpeur deriere ce code a utilisé une ia.

J'attribue la note de 20/20

=== 27efficacite.py  

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Le code fonctionne et passe les tests fournis initialement
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

La complexité de la fonction RLE(chaine) est dominée par la boucle principale qui parcourt chaque caractère de la chaîne d'entrée. Cependant, l'utilisation de l'opérateur + pour la concaténation de chaînes dans une boucle peut entraîner une complexité cumulée de O(n^2) dans le pire des cas.

* Complexité temporelle
** Boucle principale : O(n)
** Opérations internes de concaténation de chaînes : O(n^2)

L'algorithme original a une complexité O(n^2) en raison de l'utilisation de l'opérateur + pour la concaténation de chaînes. La version améliorée utilise une liste pour construire la chaîne de sortie, réduisant ainsi la complexité temporelle totale à O(n), ce qui le rend bien plus performant et adapté aux chaînes de grande taille.

J'attribue la note de 20/20

=== 25efficacite.java  

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Le code fonctionne et passe les tests fournis initialement
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

La complexité de la méthode RLE(String in) est dominée par la boucle principale qui parcourt chaque caractère de in. Les opérations effectuées à chaque itération de la boucle sont toutes O(1), et l'utilisation de StringBuilder pour la construction de la chaîne de sortie assure que les opérations d'ajout sont également O(1).

* La complexité temporelle de l'algorithme est  :
** Boucle principale : O(n)
** Opérations finales : O(n)

Cet algorithme est performant avec une complexité temporelle O(n). En utilisant StringBuilder, il évite les inefficacités des opérations de concaténation de chaînes, ce qui le rend bien adapté pour des applications pratiques de compression RLE.

J'attribue la note de 20/20

=== 24efficacite.java  

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Le code fonctionne et passe les tests fournis initialement
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

L'algorithme comporte une boucle principale qui parcourt chaque caractère de la chaîne d'entrée. Cependant, l'utilisation de l'opérateur += dans une boucle peut entraîner une complexité cumulée de O(n^2) dans le pire des cas, car chaque concaténation de chaîne avec += en Java crée une nouvelle chaîne.

* Complexité temporelle de la méthode précédente : O(n) grâce à l'utilisation de StringBuilder pour la construction de la chaîne de sortie.

* Complexité temporelle de la méthode actuelle : O(n^2) en raison de l'utilisation de l'opérateur += pour la concaténation de chaînes dans une boucle.

L'algorithme actuel, bien qu'il fonctionne correctement pour des chaînes de petite taille, peut devenir inefficace pour des chaînes plus longues. L'utilisation de StringBuilder est recommandée pour améliorer la performance et réduire la complexité à O(n).

J'attribue la note de 20/20

=== 10efficacite.java

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Non
| Es ce que l'anonymat est respecté ? | -
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | -
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | -
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | -
| Es ce que le l'algo passe tous les tests fournis initialement | -
| Es ce que le l'algo passe mes tests supplémentaires plus complets | -
|===

* L'algorithme ne compile pas, il y a une erreur car un élément est inateignable (break;).

J'attribue la note de 0/20

=== 61efficacite.java

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Le code fonctionne et passe les tests fournis initialement
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

* La complexité de la méthode RLE(String texte) est dominée par la boucle principale qui parcourt chaque caractère de texte. Donc, la complexité temporelle est O(n), où n est la longueur de texte.

* Efficacité : Pour un seul passage de compression RLE, l'algorithme est efficace avec une complexité linéaire O(n).

* Extensibilité : Lorsqu'il est appelé plusieurs fois avec le paramètre nombre, la complexité augmente linéairement avec nombre, ce qui est attendu.

L'algorithme est bien conçu pour la compression RLE. Cependant, dans des scénarios où nombre est très grand, l'algorithme pourrait devenir inefficace, mais pour des valeurs raisonnables de nombre, il reste performant.

J'attribue la note de 20/20

=== 46sobriete.java 

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Le code fonctionne et passe les tests fournis initialement
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

* Efficacité énergétique : 
** L'algorithme Java est raisonnablement efficace en termes de temps d'exécution et de mémoire utilisée. L'utilisation de StringBuilder est judicieuse pour éviter la création de nouvelles chaînes immuables à chaque concaténation, ce qui améliore l'efficacité. Les allocations dynamiques sont gérées de manière efficace.
* Optimisation potentielle : 
** L'algorithme est déjà relativement optimisé pour les allocations dynamiques. Cependant, il pourrait y avoir des gains supplémentaires en ajustant finement la gestion des tailles de mémoire pour StringBuilder afin de minimiser les redimensionnements internes.

J'attribue la note de 20/20

=== 36sobriete.java 

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Le code fonctionne et passe les tests fournis initialement
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

* Efficacité énergétique : 
** L'algorithme Java est raisonnablement efficace en termes de temps d'exécution et de mémoire utilisée. L'utilisation de StringBuilder est judicieuse pour éviter la création de nouvelles chaînes immuables à chaque concaténation, ce qui améliore l'efficacité.
* Optimisation potentielle : 
** Une optimisation pourrait consister à réduire les allocations dynamiques en utilisant des structures de données plus efficaces et en prévoyant une taille de mémoire plus précise pour StringBuilder.

J'attribue la note de 20/20

=== 20sobriete.java 

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Le code fonctionne et passe les tests fournis initialement
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

* Efficacité énergétique : 
** L'algorithme Java est raisonnablement efficace en termes de temps d'exécution et de mémoire utilisée. L'utilisation de StringBuilder améliore l'efficacité par rapport aux opérations sur les chaînes de caractères immuables.
* Optimisation potentielle : 
** Une optimisation pourrait consister à réduire les allocations dynamiques en utilisant des structures de données plus efficaces et en prévoyant une taille de mémoire plus précise pour StringBuilder.

J'attribue la note de 20/20

=== 61sobriete.c 

|===
| Problème | Sanction
| Es ce que l'algo compile ? | Oui
| Es ce que l'anonymat est respecté ? | Oui
| Es ce que le l'algo respect de la consigne sur les méthodes de Java util (pour efficacité) | Oui
| Es ce que le l'algo fonctionne ? (retour erronné, ou pas du bon type attendu) | Oui
| Es ce que le l'algo fonctionne mais ne passe pas les tests fournis initialement | Le code fonctionne et passe les tests fournis initialement
| Es ce que le l'algo passe tous les tests fournis initialement | Oui
| Es ce que le l'algo passe mes tests supplémentaires plus complets | Oui
|===

* Efficacité énergétique : 
** L'algorithme semble être relativement efficace en termes de temps d'exécution et de mémoire utilisée, étant donné qu'il traite les données linéairement. Cependant, les allocations dynamiques fréquentes peuvent augmenter la consommation d'énergie.

* Optimisation potentielle : 
** Une optimisation pourrait consister à éviter les allocations dynamiques multiples en prévoyant une taille de mémoire plus précise ou en utilisant des structures de données plus efficaces. Par exemple, en allouant une fois la mémoire nécessaire pour chaineFinale et en ajustant les indices plutôt que de réallouer la mémoire à chaque fois.

J'attribue la note de 20/20

== Conclusion / Classement

Voici le classement des algorithmes évalués (1 étant le meilleur) :

=== Pour la sobriété :

* 1 : 61sobriete.c
* 2 : 46sobriete.java
* 3 : 20sobriete.java
* 4 : 36sobriete.java

=== Pour la simplicité :

* 1 : 11simplicite.java
* 2 : 59simplicite.java
* 3 : 52simplicite.java
* 4 : 07simplicite.py
* 5 : 26simplicite.py

=== Pour l'efficacité :

* 1 : 27efficacite.py
* 2 : 61efficacite.java
* 3 : 25efficacite.java
* 4 : 24efficacite.java  
* 5 : 10efficacite.java